import fs from "node:fs";
import yaml from "js-yaml";
import { ok, Result as R, type Result } from "neverthrow";
import {
  createEmptyLockfile,
  type LockedProject,
  type Lockfile,
  parseLockfile,
} from "./lockfileSchemas.js";

/**
 * Read lockfile from disk
 */
export function readLockfile(lockfilePath: string): Result<Lockfile, Error> {
  if (!fs.existsSync(lockfilePath)) {
    return ok(createEmptyLockfile());
  }

  return R.fromThrowable(
    () => {
      const content = fs.readFileSync(lockfilePath, "utf8");
      const data = yaml.load(content);
      const parseResult = parseLockfile(data);
      if (parseResult.isErr()) {
        // eslint-disable-next-line fp/no-throw
        throw parseResult.error;
      }
      return parseResult.value;
    },
    (error) => new Error(`Failed to read lockfile: ${error}`),
  )();
}

/**
 * Write lockfile to disk
 */
export function writeLockfile(lockfilePath: string, lockfile: Lockfile): Result<void, Error> {
  return R.fromThrowable(
    () => {
      const content = yaml.dump(lockfile, {
        lineWidth: -1, // disable line wrapping
        noRefs: true,
      });
      const header = "# Generated by anydocs - do not edit manually\n";
      fs.writeFileSync(lockfilePath, header + content, "utf8");
    },
    (error) => new Error(`Failed to write lockfile: ${error}`),
  )();
}

/**
 * Update or add locked project
 */
export function updateLockedProject(lockfile: Lockfile, project: LockedProject): Lockfile {
  const index = lockfile.projects.findIndex((p) => p.name === project.name);
  if (index >= 0) {
    // Update existing
    lockfile.projects[index] = project;
  } else {
    // Add new
    lockfile.projects.push(project);
  }
  return lockfile;
}
